import OpenAI from 'openai';
import Replicate from 'replicate';

// Initialize AI services
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

const replicate = new Replicate({
  auth: process.env.REPLICATE_API_TOKEN,
});

export interface ImageGenerationOptions {
  model?: 'dalle3' | 'stable-diffusion';
  size?: '1024x1024' | '1024x1792' | '1792x1024';
  quality?: 'standard' | 'hd';
  style?: 'vivid' | 'natural';
  n?: number;
}

export interface GeneratedImage {
  url: string;
  revised_prompt?: string;
  model: string;
  size: string;
  cost?: number;
}

/**
 * Generate an image using DALL-E 3
 */
export async function generateImageWithDALLE3(
  prompt: string,
  options: ImageGenerationOptions = {}
): Promise<GeneratedImage> {
  try {
    console.log('üé® Generating image with DALL-E 3:', prompt);
    
    const response = await openai.images.generate({
      model: 'dall-e-3',
      prompt,
      size: options.size || '1024x1024',
      quality: options.quality || 'standard',
      style: options.style || 'vivid',
      n: 1,
    });

    if (!response.data || response.data.length === 0) {
      throw new Error('No image generated by DALL-E 3');
    }

    const image = response.data[0];
    
    return {
      url: image.url!,
      revised_prompt: image.revised_prompt,
      model: 'dall-e-3',
      size: options.size || '1024x1024',
      cost: 0.04, // DALL-E 3 cost per image
    };
  } catch (error) {
    console.error('‚ùå DALL-E 3 generation error:', error);
    throw new Error(`DALL-E 3 generation failed: ${error}`);
  }
}

/**
 * Generate an image using Stable Diffusion via Replicate
 */
export async function generateImageWithStableDiffusion(
  prompt: string,
  options: ImageGenerationOptions = {}
): Promise<GeneratedImage> {
  try {
    console.log('üé® Generating image with Stable Diffusion:', prompt);
    
    const output = await replicate.run(
      "stability-ai/stable-diffusion:27b93a2413e7f36cd83da926f3656280b2931564ff050bf9575f1fdf9bcd747e",
      {
        input: {
          prompt,
          width: 1024,
          height: 1024,
          num_outputs: 1,
          scheduler: "K_EULER",
          num_inference_steps: 50,
          guidance_scale: 7.5,
        }
      }
    );

    const imageUrl = Array.isArray(output) ? output[0] : output;
    
    return {
      url: imageUrl as string,
      model: 'stable-diffusion',
      size: '1024x1024',
      cost: 0.0023, // Replicate Stable Diffusion cost
    };
  } catch (error) {
    console.error('‚ùå Stable Diffusion generation error:', error);
    throw new Error(`Stable Diffusion generation failed: ${error}`);
  }
}

/**
 * Generate an image using the specified model
 */
export async function generateImage(
  prompt: string,
  options: ImageGenerationOptions = {}
): Promise<GeneratedImage> {
  const model = options.model || 'dalle3';
  
  switch (model) {
    case 'dalle3':
      return generateImageWithDALLE3(prompt, options);
    case 'stable-diffusion':
      return generateImageWithStableDiffusion(prompt, options);
    default:
      throw new Error(`Unsupported model: ${model}`);
  }
}

/**
 * Generate multiple images with the same prompt
 */
export async function generateMultipleImages(
  prompt: string,
  count: number,
  options: ImageGenerationOptions = {}
): Promise<GeneratedImage[]> {
  const promises = Array(count).fill(null).map(() => 
    generateImage(prompt, options)
  );
  
  return Promise.all(promises);
}

/**
 * Create a story-specific image prompt with character consistency
 */
export function createStoryImagePrompt(
  storyText: string,
  storyTitle: string,
  style: string = 'fantasy adventure book illustration',
  characters?: Array<{
    name: string;
    description?: string;
    appearancePrompt?: string;
    role?: string;
    emotion?: string;
    action?: string;
  }>
): string {
  // Extract key visual elements from the story text
  const visualElements = extractVisualElements(storyText);
  
  // Build character descriptions
  let characterDescriptions = '';
  if (characters && characters.length > 0) {
    const characterParts = characters.map(char => {
      let desc = char.name;
      if (char.description) desc += ` (${char.description})`;
      if (char.appearancePrompt) desc += `, ${char.appearancePrompt}`;
      if (char.emotion) desc += `, ${char.emotion} expression`;
      if (char.action) desc += `, ${char.action}`;
      return desc;
    });
    characterDescriptions = `, featuring ${characterParts.join(', ')}`;
  }
  
  // Use the first 200 characters of story text as main description
  const sceneDescription = storyText.substring(0, 200).trim();
  
  // Create a comprehensive prompt with the actual story text
  const prompt = `${style}: ${sceneDescription}${characterDescriptions}. Detailed, high quality, book illustration style, cinematic lighting`;
  
  return prompt;
}

/**
 * Extract visual elements from story text
 */
function extractVisualElements(text: string): string[] {
  const elements: string[] = [];
  
  // Common fantasy/adventure keywords
  const keywords = [
    'forest', 'cave', 'mountain', 'castle', 'dragon', 'knight', 'princess',
    'magic', 'sword', 'treasure', 'monster', 'dark', 'light', 'mysterious',
    'ancient', 'ruins', 'tower', 'bridge', 'river', 'lake', 'village',
    'wizard', 'elf', 'dwarf', 'goblin', 'troll', 'spider', 'bat',
    'crystal', 'gem', 'gold', 'silver', 'fire', 'ice', 'storm'
  ];
  
  const lowerText = text.toLowerCase();
  
  keywords.forEach(keyword => {
    if (lowerText.includes(keyword)) {
      elements.push(keyword);
    }
  });
  
  // If no specific elements found, add generic adventure elements
  if (elements.length === 0) {
    elements.push('adventure scene', 'mysterious atmosphere');
  }
  
  return elements;
}

/**
 * Generate a video using Replicate
 */
export async function generateVideoWithReplicate(
  prompt: string,
  imageUrl?: string
): Promise<{ url: string; cost: number }> {
  try {
    console.log('üé¨ Generating video with Replicate:', prompt);
    
    // Check if API token is set
    if (!process.env.REPLICATE_API_TOKEN) {
      throw new Error('REPLICATE_API_TOKEN environment variable is not set');
    }
    
    console.log('‚úÖ Replicate API token found');
    
    const Replicate = (await import('replicate')).default;
    const replicate = new Replicate({
      auth: process.env.REPLICATE_API_TOKEN,
    });

    // If we have an image, animate it. Otherwise skip for now.
    if (!imageUrl) {
      throw new Error('Video generation requires an existing image. Generate an image first, then convert it to video.');
    }

    // Use Stable Video Diffusion to animate an image
    console.log('üé¨ Calling Replicate API with image:', imageUrl);
    
    // Create and wait for the prediction
    const prediction = await replicate.predictions.create({
      version: "3f0457e4619daac51203dedb472816fd4af51f3149fa7a9e0b5ffcf1b8172438",
      input: {
        input_image: imageUrl,
        cond_aug: 0.02,
        decoding_t: 14,
        video_length: "14_frames_with_svd",
        sizing_strategy: "maintain_aspect_ratio",
        motion_bucket_id: 127,
        frames_per_second: 6,
      }
    });

    console.log('üîç Prediction created:', prediction.id, 'status:', prediction.status);

    // Wait for the prediction to complete
    let finalPrediction = prediction;
    while (finalPrediction.status !== 'succeeded' && finalPrediction.status !== 'failed' && finalPrediction.status !== 'canceled') {
      await new Promise(resolve => setTimeout(resolve, 2000)); // Poll every 2 seconds
      finalPrediction = await replicate.predictions.get(prediction.id);
      console.log('‚è≥ Prediction status:', finalPrediction.status);
    }

    if (finalPrediction.status === 'failed') {
      throw new Error(`Replicate prediction failed: ${finalPrediction.error}`);
    }

    if (finalPrediction.status === 'canceled') {
      throw new Error('Replicate prediction was canceled');
    }

    console.log('üîç Final prediction output type:', typeof finalPrediction.output);
    console.log('üîç Final prediction output:', JSON.stringify(finalPrediction.output, null, 2));

    // Extract video URL from the prediction output
    let videoUrl: string | null = null;
    const output = finalPrediction.output;
    
    if (typeof output === 'string') {
      videoUrl = output;
    } else if (Array.isArray(output) && output.length > 0) {
      videoUrl = output[0];
    } else if (output && typeof output === 'object') {
      videoUrl = (output as any).output || (output as any).url || (output as any)[0];
    }
    
    if (!videoUrl || typeof videoUrl !== 'string') {
      console.error('‚ùå Could not extract video URL from output:', output);
      throw new Error(`No video URL returned from Replicate. Output type: ${typeof output}, Output: ${JSON.stringify(output)}`);
    }

    console.log('‚úÖ Video generated:', videoUrl);

    return {
      url: videoUrl,
      cost: 0.10, // Approximate cost per video
    };
  } catch (error) {
    console.error('‚ùå Video generation error:', error);
    throw new Error(`Video generation failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

// Legacy function name for compatibility
export const generateVideoWithRunway = generateVideoWithReplicate;
