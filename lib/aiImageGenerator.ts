import OpenAI from 'openai';
import Replicate from 'replicate';

// Initialize AI services
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

const replicate = new Replicate({
  auth: process.env.REPLICATE_API_TOKEN,
});

export interface ImageGenerationOptions {
  model?: 'dalle3' | 'stable-diffusion' | 'stable-diffusion-img2img';
  size?: '1024x1024' | '1024x1792' | '1792x1024';
  quality?: 'standard' | 'hd';
  style?: 'vivid' | 'natural';
  n?: number;
  referenceImageUrl?: string; // For img2img - reference image to match style
  strength?: number; // For img2img - how much to follow reference (0-1, lower = more similar)
}

export interface GeneratedImage {
  url: string;
  revised_prompt?: string;
  model: string;
  size: string;
  cost?: number;
}

/**
 * Sanitize prompt for DALL-E 3 safety system
 * Removes potentially problematic words and phrases and makes content child-friendly
 */
function sanitizePromptForDALLE3(prompt: string): string {
  // Remove words that might trigger safety filters or create scary images
  const problematicWords = [
    'scary', 'horror', 'menacing', 'creepy', 'nightmarish', 'gothic',
    'dark shadows', 'ominous', 'frightening', 'terrifying', 'sinister',
    'evil', 'demonic', 'haunted', 'ghostly', 'spooky', 'eerie',
    'threatening', 'dangerous', 'violent', 'blood', 'death', 'skull',
    'bone', 'skeleton', 'grave', 'tomb', 'crypt', 'witchcraft', 'cursed'
  ];
  
  let sanitized = prompt;
  problematicWords.forEach(word => {
    const regex = new RegExp(word, 'gi');
    sanitized = sanitized.replace(regex, '');
  });
  
  // Replace scary character descriptions with friendly ones
  const scaryReplacements: { [key: string]: string } = {
    'old witch': 'friendly magical character',
    'witch': 'magical character',
    'wizard': 'friendly wizard',
    'dark forest': 'enchanted forest',
    'dark': 'mysterious but bright',
    'shadowy': 'mysterious but well-lit',
    'gaunt': 'wise and kind',
    'bony': 'slender',
    'sharp teeth': 'friendly smile',
    'clawed hands': 'magical hands',
    'pointed nose': 'distinctive nose',
    'hooked nose': 'distinctive nose'
  };
  
  Object.entries(scaryReplacements).forEach(([scary, friendly]) => {
    const regex = new RegExp(scary, 'gi');
    sanitized = sanitized.replace(regex, friendly);
  });
  
  // Clean up extra spaces
  sanitized = sanitized.replace(/\s+/g, ' ').trim();
  
  return sanitized;
}

/**
 * Generate an image using DALL-E 3
 */
export async function generateImageWithDALLE3(
  prompt: string,
  options: ImageGenerationOptions = {}
): Promise<GeneratedImage> {
  try {
    // Sanitize prompt for DALL-E 3 safety system
    const sanitizedPrompt = sanitizePromptForDALLE3(prompt);
    console.log('üé® Generating image with DALL-E 3:', sanitizedPrompt);
    
    const response = await openai.images.generate({
      model: 'dall-e-3',
      prompt: sanitizedPrompt,
      size: options.size || '1024x1024',
      quality: options.quality || 'standard',
      style: 'vivid', // Use 'vivid' for Disney-style vibrant colors and child-friendly aesthetic
      n: 1,
    });

    if (!response.data || response.data.length === 0) {
      throw new Error('No image generated by DALL-E 3');
    }

    const image = response.data[0];
    
    return {
      url: image.url!,
      revised_prompt: image.revised_prompt,
      model: 'dall-e-3',
      size: options.size || '1024x1024',
      cost: 0.04, // DALL-E 3 cost per image
    };
  } catch (error: any) {
    console.error('‚ùå DALL-E 3 generation error:', error);
    
    // Check if it's a safety system rejection
    if (error?.message?.includes('safety system') || error?.status === 400) {
      throw new Error('DALL-E_3_SAFETY_REJECTION'); // Special error code for fallback
    }
    
    throw new Error(`DALL-E 3 generation failed: ${error}`);
  }
}

/**
 * Generate an image using Stable Diffusion via Replicate
 */
export async function generateImageWithStableDiffusion(
  prompt: string,
  options: ImageGenerationOptions = {}
): Promise<GeneratedImage> {
  try {
    console.log('üé® Generating image with Stable Diffusion:', prompt);
    
    const output = await replicate.run(
      "stability-ai/stable-diffusion:27b93a2413e7f36cd83da926f3656280b2931564ff050bf9575f1fdf9bcd747e",
      {
        input: {
          prompt,
          width: 1024,
          height: 1024,
          num_outputs: 1,
          scheduler: "K_EULER",
          num_inference_steps: 50,
          guidance_scale: 7.5,
        }
      }
    );

    const imageUrl = Array.isArray(output) ? output[0] : output;
    
    return {
      url: imageUrl as string,
      model: 'stable-diffusion',
      size: '1024x1024',
      cost: 0.0023, // Replicate Stable Diffusion cost
    };
  } catch (error) {
    console.error('‚ùå Stable Diffusion generation error:', error);
    throw new Error(`Stable Diffusion generation failed: ${error}`);
  }
}

/**
 * Generate an image using Stable Diffusion Image-to-Image via Replicate
 * This uses a reference image to maintain style consistency
 */
export async function generateImageWithStableDiffusionImg2Img(
  prompt: string,
  referenceImageUrl: string,
  options: ImageGenerationOptions = {}
): Promise<GeneratedImage> {
  try {
    console.log('üé® Generating image with Stable Diffusion img2img:', prompt);
    console.log('üñºÔ∏è Using reference image for style consistency:', referenceImageUrl);
    
    // Download reference image
    const imageResponse = await fetch(referenceImageUrl);
    if (!imageResponse.ok) {
      throw new Error(`Failed to fetch reference image: ${imageResponse.statusText}`);
    }
    
    const imageBuffer = await imageResponse.arrayBuffer();
    const imageBase64 = Buffer.from(imageBuffer).toString('base64');
    const imageDataUri = `data:image/jpeg;base64,${imageBase64}`;
    
    // Use SDXL which has good img2img support
    // strength: 0.6-0.7 is good for maintaining style while allowing scene changes
    const strength = options.strength || 0.65;
    
    const output = await replicate.run(
      "stability-ai/sdxl:39ed52f2a78e934b3ba6e2a89f5b1c712de7dfea535525255b1aa35c5565e08b",
      {
        input: {
          prompt: prompt,
          image: imageDataUri,
          strength: strength, // Lower = more similar to reference (0.5-0.8 is good range)
          width: 1024,
          height: 1024,
          num_outputs: 1,
          num_inference_steps: 50,
          guidance_scale: 7.5,
          scheduler: "K_EULER",
        }
      }
    );

    const imageUrl = Array.isArray(output) ? output[0] : output;
    
    return {
      url: imageUrl as string,
      model: 'stable-diffusion-img2img',
      size: '1024x1024',
      cost: 0.0023, // Similar cost to regular SD
    };
  } catch (error) {
    console.error('‚ùå Stable Diffusion img2img generation error:', error);
    throw new Error(`Stable Diffusion img2img generation failed: ${error}`);
  }
}

/**
 * Generate an image using the specified model
 * Automatically falls back to Stable Diffusion if DALL-E 3 is rejected by safety system
 */
export async function generateImage(
  prompt: string,
  options: ImageGenerationOptions = {}
): Promise<GeneratedImage> {
  const model = options.model || 'dalle3';
  
  try {
    switch (model) {
      case 'dalle3':
        return await generateImageWithDALLE3(prompt, options);
      case 'stable-diffusion':
        return await generateImageWithStableDiffusion(prompt, options);
      case 'stable-diffusion-img2img':
        if (!options.referenceImageUrl) {
          throw new Error('referenceImageUrl is required for stable-diffusion-img2img model');
        }
        return await generateImageWithStableDiffusionImg2Img(prompt, options.referenceImageUrl, options);
      default:
        throw new Error(`Unsupported model: ${model}`);
    }
  } catch (error: any) {
    // If DALL-E 3 is rejected by safety system, fall back to Stable Diffusion
    if (model === 'dalle3' && error?.message?.includes('DALL-E_3_SAFETY_REJECTION')) {
      console.warn('‚ö†Ô∏è DALL-E 3 rejected by safety system, falling back to Stable Diffusion');
      return await generateImageWithStableDiffusion(prompt, options);
    }
    throw error;
  }
}

/**
 * Generate multiple images with the same prompt
 */
export async function generateMultipleImages(
  prompt: string,
  count: number,
  options: ImageGenerationOptions = {}
): Promise<GeneratedImage[]> {
  const promises = Array(count).fill(null).map(() => 
    generateImage(prompt, options)
  );
  
  return Promise.all(promises);
}

/**
 * Analyze an image using GPT-4 Vision to extract detailed style descriptors
 */
export async function analyzeImageStyle(imageUrl: string): Promise<string> {
  try {
    console.log('üîç Analyzing image style with GPT-4 Vision:', imageUrl);
    
    const response = await openai.chat.completions.create({
      model: 'gpt-4o',
      messages: [
        {
          role: 'system',
          content: `You are an expert art director and visual style analyst specializing in child-friendly, Disney and anime-style illustrations. Analyze the provided image and extract detailed style descriptors that can be used to recreate the EXACT same visual style in other images. 

CRITICAL: Focus on capturing the EXACT style characteristics:
- Artistic style (e.g., "Disney-style animation", "anime-inspired", "watercolor", "digital painting")
- Color palette and mood (warm/cool, vibrant/muted, bright/dark) - be specific about colors, emphasize bright and cheerful colors
- Lighting characteristics (soft/harsh, warm/cool, direction, brightness level) - emphasize warm, bright lighting
- Character design approach (realistic/stylized, proportions, facial features) - emphasize friendly, approachable, non-threatening appearances
- Overall mood and atmosphere (friendly, whimsical, magical, light, cheerful) - emphasize positive, child-appropriate moods
- Composition style and camera angle
- Texture and rendering quality
- Any specific visual elements that define the style

IMPORTANT: 
- ALWAYS emphasize if the image has a friendly, warm, family-friendly, Disney/anime style suitable for children
- ALWAYS note if characters appear friendly and approachable, never scary or threatening
- ALWAYS emphasize bright, warm lighting and cheerful atmosphere
- If the image avoids dark/scary elements, explicitly state that
- Be very specific about what makes this style unique and child-appropriate

Return ONLY a detailed, specific style description (2-3 sentences) that can be used in image generation prompts to match this exact visual style. The description must emphasize child-friendly, Disney/anime aesthetic.`
        },
        {
          role: 'user',
          content: [
            {
              type: 'image_url',
              image_url: {
                url: imageUrl
              }
            },
            {
              type: 'text',
              text: 'Analyze this image and provide a detailed style description that can be used to match this exact visual style in other images.'
            }
          ] as any
        }
      ],
      max_tokens: 500,
    });

    const styleDescription = response.choices[0]?.message?.content || '';
    console.log('‚úÖ Extracted style description:', styleDescription);
    return styleDescription;
  } catch (error) {
    console.error('‚ùå Image style analysis error:', error);
    // Return empty string if analysis fails - we'll fall back to text-based matching
    return '';
  }
}

/**
 * Create a story-specific image prompt with character consistency
 */
export function createStoryImagePrompt(
  storyText: string,
  storyTitle: string,
  style: string = 'Disney-style animation, polished and professional, expressive characters, vibrant colors, soft rounded shapes, family-friendly aesthetic, cinematic quality',
  characters?: Array<{
    name: string;
    description?: string;
    appearancePrompt?: string;
    role?: string;
    emotion?: string;
    action?: string;
  }>,
  referenceImageUrl?: string,
  extractedStyleDescription?: string
): string {
  // Build character descriptions with better structure
  let characterSection = '';
  if (characters && characters.length > 0) {
    const characterParts = characters.map(char => {
      let desc = char.name;
      if (char.appearancePrompt) {
        // Sanitize character appearance prompts to be child-friendly
        desc += `, ${sanitizePromptForDALLE3(char.appearancePrompt)}`;
      } else if (char.description) {
        desc += `, ${sanitizePromptForDALLE3(char.description)}`;
      }
      if (char.emotion) {
        // Ensure emotions are child-appropriate
        const friendlyEmotion = char.emotion.toLowerCase().includes('angry') || 
                               char.emotion.toLowerCase().includes('scary') ||
                               char.emotion.toLowerCase().includes('frightened')
          ? 'curious or surprised' : char.emotion;
        desc += `, showing ${friendlyEmotion} expression`;
      }
      if (char.action) {
        desc += `, ${char.action}`;
      }
      return desc;
    });
    characterSection = ` Characters: ${characterParts.join('. ')}.`;
  }
  
  // Clean up the story text for better AI processing
  let cleanStoryText = storyText
    .replace(/\*\*/g, '') // Remove markdown bold
    .replace(/\*/g, '') // Remove markdown italic
    .replace(/#{1,6}\s/g, '') // Remove markdown headers
    .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1') // Convert markdown links to plain text
    .replace(/\n+/g, ' ') // Replace newlines with spaces
    .replace(/\s+/g, ' ') // Normalize whitespace
    .trim();
  
  // Sanitize the story text to make it child-friendly
  cleanStoryText = sanitizePromptForDALLE3(cleanStoryText);
  
  // Use up to 600 characters of the story text for better context
  const sceneDescription = cleanStoryText.substring(0, 600).trim();
  
  // Build style reference section - this MUST come FIRST to ensure DALL-E 3 prioritizes it
  let styleReferenceSection = '';
  if (extractedStyleDescription) {
    // Use the AI-extracted style description for precise matching
    // Put it FIRST in the prompt so DALL-E 3 prioritizes style over content
    // Sanitize extracted description to remove problematic words
    const sanitizedDescription = sanitizePromptForDALLE3(extractedStyleDescription);
    styleReferenceSection = `STYLE REQUIREMENTS (MUST MATCH EXACTLY): ${sanitizedDescription}. CRITICAL: You MUST use this exact style - same artistic approach, same color palette, same lighting mood, same character design style, same overall atmosphere. `;
  } else if (referenceImageUrl) {
    // Fallback to text-based instructions if we don't have extracted style
    // Use positive language only to avoid safety system triggers
    styleReferenceSection = `STYLE REQUIREMENTS (MUST MATCH EXACTLY): Match the exact same artistic style, color palette, lighting mood, character design approach, and visual aesthetic as the first scene image from this story. Use the same warm, inviting lighting. Characters must have the same friendly, expressive design style. Maintain the same whimsical, storybook illustration quality with vibrant colors and soft, rounded shapes. Keep the same family-friendly, magical atmosphere. The visual style must be IDENTICAL to the first image. `;
  }
  
  // Enhanced default style to be more explicit about Disney/anime and child-friendly
  const defaultStyle = style || 'Disney-style animation, anime-inspired character design, polished and professional, expressive friendly characters, vibrant bright colors, soft rounded shapes, family-friendly aesthetic, cinematic quality, warm inviting lighting, cheerful magical atmosphere, suitable for children';
  
  // Build negative instructions to prevent unwanted styles (using safer language for DALL-E 3)
  const negativeInstructions = referenceImageUrl || extractedStyleDescription 
    ? ' Use warm, bright lighting. Maintain friendly, expressive character designs. Keep a light, cheerful atmosphere. All characters must appear friendly and approachable, never scary or threatening.'
    : ' All characters must appear friendly and approachable, never scary or threatening. Use warm, bright lighting throughout.';
  
  // Build a well-structured prompt with style FIRST
  // Structure: [Style Requirements FIRST] [Base Style] [Scene Description] [Characters] [Negative Instructions] [Quality Requirements]
  const prompt = `${styleReferenceSection}${defaultStyle}. Scene: ${sceneDescription}${characterSection}${negativeInstructions} High quality illustration, dynamic composition, expressive and appealing, warm inviting atmosphere, family-friendly, Disney Pixar style, anime-inspired, child-appropriate, no scary elements, no dark shadows, no text, no words, no writing, no letters, no dialogue boxes, no UI elements`;
  
  return prompt;
}


/**
 * Generate a video using Replicate
 */
export async function generateVideoWithReplicate(
  prompt: string,
  imageUrl?: string
): Promise<{ url: string; cost: number }> {
  try {
    console.log('üé¨ Generating video with Replicate:', prompt);
    
    // Check if API token is set
    if (!process.env.REPLICATE_API_TOKEN) {
      throw new Error('REPLICATE_API_TOKEN environment variable is not set');
    }
    
    console.log('‚úÖ Replicate API token found');
    
    const Replicate = (await import('replicate')).default;
    const replicate = new Replicate({
      auth: process.env.REPLICATE_API_TOKEN,
    });

    // If we have an image, animate it. Otherwise skip for now.
    if (!imageUrl) {
      throw new Error('Video generation requires an existing image. Generate an image first, then convert it to video.');
    }

    // Use Kling v2.1 to animate an image
    console.log('üé¨ Calling Replicate API with Kling v2.1, image:', imageUrl);
    
    // Create and wait for the prediction
    const prediction = await replicate.predictions.create({
      model: "kwaivgi/kling-v2.1",
      input: {
        prompt: prompt.substring(0, 200), // Use story context for video animation
        start_image: imageUrl,
        aspect_ratio: "16:9",
        duration: 5, // 5 second video
        negative_prompt: "blurry, low quality, distorted"
      }
    });

    console.log('üîç Prediction created:', prediction.id, 'status:', prediction.status);

    // Wait for the prediction to complete
    let finalPrediction = prediction;
    while (finalPrediction.status !== 'succeeded' && finalPrediction.status !== 'failed' && finalPrediction.status !== 'canceled') {
      await new Promise(resolve => setTimeout(resolve, 2000)); // Poll every 2 seconds
      finalPrediction = await replicate.predictions.get(prediction.id);
      console.log('‚è≥ Prediction status:', finalPrediction.status);
    }

    if (finalPrediction.status === 'failed') {
      throw new Error(`Replicate prediction failed: ${finalPrediction.error}`);
    }

    if (finalPrediction.status === 'canceled') {
      throw new Error('Replicate prediction was canceled');
    }

    console.log('üîç Final prediction output type:', typeof finalPrediction.output);
    console.log('üîç Final prediction output:', JSON.stringify(finalPrediction.output, null, 2));

    // Extract video URL from the prediction output
    let videoUrl: string | null = null;
    const output = finalPrediction.output;
    
    if (typeof output === 'string') {
      videoUrl = output;
    } else if (Array.isArray(output) && output.length > 0) {
      videoUrl = output[0];
    } else if (output && typeof output === 'object') {
      videoUrl = (output as any).output || (output as any).url || (output as any)[0];
    }
    
    if (!videoUrl || typeof videoUrl !== 'string') {
      console.error('‚ùå Could not extract video URL from output:', output);
      throw new Error(`No video URL returned from Replicate. Output type: ${typeof output}, Output: ${JSON.stringify(output)}`);
    }

    console.log('‚úÖ Video generated:', videoUrl);

    return {
      url: videoUrl,
      cost: 0.10, // Approximate cost per video
    };
  } catch (error) {
    console.error('‚ùå Video generation error:', error);
    throw new Error(`Video generation failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

// Legacy function name for compatibility
export const generateVideoWithRunway = generateVideoWithReplicate;
